<svelte:window on:keyup="onKeyup(event)" />
<div
  ref:modal
  class="svelte-modal"
  tabindex="-1"
  data-center={center}
  data-hidden={hidden}
  style="z-index: {zIndex}; opacity: {modalStyle.opacity};">
  <div
    ref:content
    class="content"
    style="transform: scale({contentStyle.scale});">
    <slot />
  </div>
  <div
    on:click="onScrimPress()"
    ref:scrim
    class="svelte-modal-scrim"
    style="z-index: {zIndex - 1}; " />
</div>

<style>
  .svelte-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 100%;
    display: flex;
    align-items: flex-start;
    justify-content: center;
  }

  .svelte-modal-scrim {
    background: rgba(0, 0, 0, 0.5);
    position: fixed;
    top: 0;
    bottom: 0;
    right: 0;
    left: 0;
  }

  [data-center="true"] {
    align-items: center;
  }

  [data-hidden="true"] {
    visibility: hidden;
  }

  .content {
    max-width: 100vw;
    max-height: 100vh;
    overflow: visible;
    z-index: 1;
  }
</style>

<script>
  import { spring } from "svelte-extras";
  import FocusTrap from "focus-trap";
  import makeModalStackable from "./lib/make-modal-stackable";

  // TODO: write a smaller, less "featured" focusTrap. It really just needs to trap focus
  const makeFocusTrap = ({ rootElement }) => {
    return FocusTrap(rootElement, {
      initialFocus: rootElement,
      fallbackFocus: rootElement,
      escapeDeactivates: false,
      returnFocusOnDeactivate: true,
      clickOutsideDeactivates: false
    });
  };

  /* TODO: maybe make a way to accept custom transitions */
  // which might conflict with this todo:
  /* TODO: be fancy and take a touch/click/element position to transition in from */
  const STYLE = {
    modal: { open: { opacity: 1 }, hidden: { opacity: 0 } },
    content: { open: { scale: 1 }, hidden: { scale: 0.9 } }
  };
  const DEFAULTS = {
    initiallyHidden: false,
    initialFocusElement: false,
    center: true,
    zIndexBase: 1,
    pressScrimToDismiss: true,
    escToDismiss: true,
    trapFocus: true
  };

  [STYLE, DEFAULTS].forEach(Object.freeze);

  export default {
    tag: "svelte-modal",

    setup(Modal) {
      Object.assign(Modal, { DEFAULTS });
    },

    //   components: { Scrim },

    data() {
      return Object.assign(
        {
          hidden: true,
          hiding: false,
          opening: false,
          inForeground: false, // to handle stacking of multiple modals open at once
          modalStyle: STYLE.modal.hidden,
          contentStyle: STYLE.content.hidden
        },
        DEFAULTS
      );
    },

    computed: {
      transitioning: ({ hiding, opening }) => hiding || opening,
      open: ({ hidden, transitioning }) => !hidden && !transitioning,
      zIndex: ({ zIndexBase, inForeground }) =>
        inForeground ? zIndexBase : zIndexBase - 1
    },

    oncreate() {
      this.on("open", () => this.open());
      this.on("dismiss", e => this.dismiss(e));
      this.on("close", e => this.close(e));

      const rootElement = this.refs.modal;

      this.focusTrap = makeFocusTrap({ rootElement });
      this.on("hiding", () => this.focusTrap.deactivate());
      this.on("destroy", () => this.focusTrap.deactivate());

      makeModalStackable(this);

      this.on("opening", () => {
        if (this.get().trapFocus) {
          this.focusTrap.activate();
        }
        setTimeout(() => {
          /* focusTrap seems unable to focus the element
           putting activate() in the setTimeout does not help
           Focusing it manually works just fine,
           and we need to manually focus anyway when trapFocus is false
           also, I don't think focusTrap needs to concern itself with focusing elements
        */
          this.focusInitialFocusElement();
        });
      });
      console.log("looking for initiallyHidden", this);
      if (!this.get().initiallyHidden) {
        this.open();
      }
    },

    methods: {
      spring(key, end, options) {
        options = options || { stiffness: 0.5, damping: 1 };
        return spring.call(this, key, end, options);
      },

      focusInitialFocusElement() {
        const initialFocusElement = this.get().initialFocusElement;
        initialFocusElement && initialFocusElement.focus();
      },

      onKeyup(event) {
        const shouldDismiss =
          event.key.toLowerCase() === "escape" &&
          this.get().escToDismiss &&
          this.get().inForeground;
        if (shouldDismiss) {
          this.dismiss();
        }
      },

      onScrimPress() {
        if (this.get("pressScrimToDismiss")) {
          this.dismiss();
        }
      },

      open() {
        if (this.get().open || this.get().opening) {
          return;
        }

        this.set({ opening: true, hiding: false, hidden: false });
        this.fire("opening");

        Promise.all([
          this.spring("modalStyle", STYLE.modal.open),
          this.spring("contentStyle", STYLE.content.open)
        ]).then(() => {
          this.set({ opening: false });
          this.fire("opened");
        });

        return this;
      },

      hide(reason, result) {
        if (this.get().hidden || this.get().hiding) {
          return;
        }

        this.set({ opening: false, hiding: true });

        this.fire("result", result);
        this.fire(reason, result);
        this.fire("hiding");

        Promise.all([
          this.spring("modalStyle", STYLE.modal.hidden),
          this.spring("contentStyle", STYLE.content.hidden)
        ]).then(() => {
          this.set({ hiding: false, hidden: true });
          this.fire("hidden");
        });

        return this;
      },

      close(result) {
        return this.hide("closed", result);
      },

      dismiss(result) {
        return this.hide("dismissed", result);
      },

      background() {
        this.focusTrap.pause();
        this.set({ inForeground: false });
      },

      foreground(modal) {
        this.focusTrap.unpause();
        this.focusInitialFocusElement();
        this.set({ inForeground: true });
      }
    }
  };
</script>
